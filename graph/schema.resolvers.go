package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fitfinance/graph/model"
	"time"

	"github.com/labstack/gommon/log"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// UpdateFitnessData is the resolver for the updateFitnessData field.
func (r *mutationResolver) UpdateFitnessData(ctx context.Context, input model.FitnessDataInput) (*model.FitnessData, error) {
	log.Info("Updating fitness data")
	collection := r.DbClient.Database("Fitness").Collection("tracking_data")

	layout := "02-01-2006" // dd-mm-yyyy

	date, err := time.Parse(layout, input.Date)
	if err != nil {
		log.Info("Cannot parse date field")
	}

	data := &model.FitnessData{
		UserID:    input.UserID,
		Date:      date,
		StepCount: input.StepCount,
		Gym:       input.Gym,
		Sport:     input.Sport,
	}
	if data.Sport {
		data.SportType = input.SportType
		data.Duration = input.Duration
	}
	query := bson.D{
		{"userid", input.UserID},
		{"date", date},
	}
	opts := options.FindOneAndUpdate().SetUpsert(true)
	collection.FindOneAndUpdate(ctx, query, bson.M{"$set": data}, opts)
	if err != nil {
		log.Error("Error occured while inserting to db")
	}
	return data, err
}

// GetFitnessData is the resolver for the getFitnessData field.
func (r *queryResolver) GetFitnessData(ctx context.Context, input model.UserInput) (*model.FitnessData, error) {
	log.Info("Fetching fitness data")
	collection := r.DbClient.Database("Fitness").Collection("tracking_data")

	filter := bson.D{
		{"userid", input.UserID}}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		log.Error("Error fetching the fitness data")
	}

	var results []model.FitnessData
	if err = cursor.All(ctx, &results); err != nil {
		log.Error("Error reading the fitness results")
	}

	data := &model.FitnessData{}
	for _, result := range results {
		data.StepCount += result.StepCount
	}

	return data, nil
}

// GetWeeklyFitnessData is the resolver for the getWeeklyFitnessData field.
func (r *queryResolver) GetWeeklyFitnessData(ctx context.Context, input int) (*model.WeeklyFitnessData, error) {
	log.Info("Fetching fitness data")
	collection := r.DbClient.Database("Fitness").Collection("tracking_data")

	currentTime := time.Now().UTC().Truncate(24 * time.Hour)
	weekday := int(currentTime.Weekday())
	startOfWeek := currentTime.AddDate(0, 0, -weekday)
	filter := bson.D{
		{"userid", input},
		{"date", bson.D{
			{"$gte", startOfWeek},
			{"$lte", currentTime},
		}},
	}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		log.Error("Error fetching the fitness data")
	}

	var results []model.FitnessData
	if err = cursor.All(ctx, &results); err != nil {
		log.Error("Error reading the fitness results")
	}

	weeklyData := &model.WeeklyFitnessData{
		SportType: make([]*string, 0),
	}
	for _, fitnessData := range results {
		weeklyData.StepCount += fitnessData.StepCount
		if fitnessData.Gym {
			weeklyData.Gym += 1
		}
		if fitnessData.Sport {
			weeklyData.Sport += 1
		}
		if fitnessData.Sport && fitnessData.SportType != nil {
			weeklyData.SportType = append(weeklyData.SportType, fitnessData.SportType)
			weeklyData.Duration = append(weeklyData.Duration, fitnessData.Duration)
		}
	}

	return weeklyData, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
